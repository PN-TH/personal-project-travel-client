{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _inheritsLoose from \"@babel/runtime/helpers/esm/inheritsLoose\";\nimport { getStatusProps, isServer, isValidTimeout, noop, replaceEqualDeep, shallowEqualObjects, timeUntilStale } from './utils';\nimport { notifyManager } from './notifyManager';\nimport { focusManager } from './focusManager';\nimport { Subscribable } from './subscribable';\nexport var QueryObserver = /*#__PURE__*/function (_Subscribable) {\n  _inheritsLoose(QueryObserver, _Subscribable);\n\n  function QueryObserver(client, options) {\n    var _this;\n\n    _this = _Subscribable.call(this) || this;\n    _this.client = client;\n    _this.options = options;\n    _this.initialDataUpdateCount = 0;\n    _this.initialErrorUpdateCount = 0;\n    _this.trackedProps = [];\n\n    _this.bindMethods();\n\n    _this.setOptions(options);\n\n    return _this;\n  }\n\n  var _proto = QueryObserver.prototype;\n\n  _proto.bindMethods = function bindMethods() {\n    this.remove = this.remove.bind(this);\n    this.refetch = this.refetch.bind(this);\n  };\n\n  _proto.onSubscribe = function onSubscribe() {\n    if (this.listeners.length === 1) {\n      this.updateQuery();\n      this.currentQuery.addObserver(this);\n\n      if (this.willFetchOnMount()) {\n        this.executeFetch();\n      }\n\n      this.updateTimers();\n    }\n  };\n\n  _proto.onUnsubscribe = function onUnsubscribe() {\n    if (!this.listeners.length) {\n      this.destroy();\n    }\n  };\n\n  _proto.willLoadOnMount = function willLoadOnMount() {\n    return this.options.enabled !== false && !this.currentQuery.state.dataUpdatedAt && !(this.currentQuery.state.status === 'error' && this.options.retryOnMount === false);\n  };\n\n  _proto.willRefetchOnMount = function willRefetchOnMount() {\n    return this.options.enabled !== false && this.currentQuery.state.dataUpdatedAt > 0 && (this.options.refetchOnMount === 'always' || this.options.refetchOnMount !== false && this.isStale());\n  };\n\n  _proto.willFetchOnMount = function willFetchOnMount() {\n    return this.willLoadOnMount() || this.willRefetchOnMount();\n  };\n\n  _proto.willFetchOnReconnect = function willFetchOnReconnect() {\n    return this.options.enabled !== false && (this.options.refetchOnReconnect === 'always' || this.options.refetchOnReconnect !== false && this.isStale());\n  };\n\n  _proto.willFetchOnWindowFocus = function willFetchOnWindowFocus() {\n    return this.options.enabled !== false && (this.options.refetchOnWindowFocus === 'always' || this.options.refetchOnWindowFocus !== false && this.isStale());\n  };\n\n  _proto.willFetchOptionally = function willFetchOptionally() {\n    return this.options.enabled !== false && this.isStale();\n  };\n\n  _proto.isStale = function isStale() {\n    return this.currentQuery.isStaleByTime(this.options.staleTime);\n  };\n\n  _proto.destroy = function destroy() {\n    this.listeners = [];\n    this.clearTimers();\n    this.currentQuery.removeObserver(this);\n  };\n\n  _proto.setOptions = function setOptions(options) {\n    var prevOptions = this.options;\n    var prevQuery = this.currentQuery;\n    this.options = this.client.defaultQueryObserverOptions(options);\n\n    if (typeof this.options.enabled !== 'undefined' && typeof this.options.enabled !== 'boolean') {\n      throw new Error('Expected enabled to be a boolean');\n    } // Keep previous query key if the user does not supply one\n\n\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey;\n    }\n\n    this.updateQuery(); // Take no further actions if there are no subscribers\n\n    if (!this.listeners.length) {\n      return;\n    } // If we subscribed to a new query, optionally fetch and update refetch\n\n\n    if (this.currentQuery !== prevQuery) {\n      this.optionalFetch();\n      this.updateTimers();\n      return;\n    } // Optionally fetch if the query became enabled\n\n\n    if (this.options.enabled !== false && prevOptions.enabled === false) {\n      this.optionalFetch();\n    } // Update stale interval if needed\n\n\n    if (this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime) {\n      this.updateStaleTimeout();\n    } // Update refetch interval if needed\n\n\n    if (this.options.enabled !== prevOptions.enabled || this.options.refetchInterval !== prevOptions.refetchInterval) {\n      this.updateRefetchInterval();\n    }\n  };\n\n  _proto.getCurrentResult = function getCurrentResult() {\n    return this.currentResult;\n  };\n\n  _proto.getTrackedCurrentResult = function getTrackedCurrentResult() {\n    return this.trackedCurrentResult;\n  };\n\n  _proto.getNextResult = function getNextResult(options) {\n    var _this2 = this;\n\n    return new Promise(function (resolve, reject) {\n      var unsubscribe = _this2.subscribe(function (result) {\n        if (!result.isFetching) {\n          unsubscribe();\n\n          if (result.isError && (options == null ? void 0 : options.throwOnError)) {\n            reject(result.error);\n          } else {\n            resolve(result);\n          }\n        }\n      });\n    });\n  };\n\n  _proto.getCurrentQuery = function getCurrentQuery() {\n    return this.currentQuery;\n  };\n\n  _proto.remove = function remove() {\n    this.client.getQueryCache().remove(this.currentQuery);\n  };\n\n  _proto.refetch = function refetch(options) {\n    return this.fetch(options);\n  };\n\n  _proto.fetch = function fetch(fetchOptions) {\n    var _this3 = this;\n\n    return this.executeFetch(fetchOptions).then(function () {\n      _this3.updateResult();\n\n      return _this3.currentResult;\n    });\n  };\n\n  _proto.optionalFetch = function optionalFetch() {\n    if (this.willFetchOptionally()) {\n      this.executeFetch();\n    }\n  };\n\n  _proto.executeFetch = function executeFetch(fetchOptions) {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery(); // Fetch\n\n    var promise = this.currentQuery.fetch(this.options, fetchOptions);\n\n    if (!(fetchOptions == null ? void 0 : fetchOptions.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  };\n\n  _proto.updateStaleTimeout = function updateStaleTimeout() {\n    var _this4 = this;\n\n    this.clearStaleTimeout();\n\n    if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {\n      return;\n    }\n\n    var time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime); // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n\n    var timeout = time + 1;\n    this.staleTimeoutId = setTimeout(function () {\n      if (!_this4.currentResult.isStale) {\n        var prevResult = _this4.currentResult;\n\n        _this4.updateResult();\n\n        _this4.notify({\n          listeners: _this4.shouldNotifyListeners(prevResult, _this4.currentResult),\n          cache: true\n        });\n      }\n    }, timeout);\n  };\n\n  _proto.updateRefetchInterval = function updateRefetchInterval() {\n    var _this5 = this;\n\n    this.clearRefetchInterval();\n\n    if (isServer || this.options.enabled === false || !isValidTimeout(this.options.refetchInterval)) {\n      return;\n    }\n\n    this.refetchIntervalId = setInterval(function () {\n      if (_this5.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        _this5.executeFetch();\n      }\n    }, this.options.refetchInterval);\n  };\n\n  _proto.updateTimers = function updateTimers() {\n    this.updateStaleTimeout();\n    this.updateRefetchInterval();\n  };\n\n  _proto.clearTimers = function clearTimers() {\n    this.clearStaleTimeout();\n    this.clearRefetchInterval();\n  };\n\n  _proto.clearStaleTimeout = function clearStaleTimeout() {\n    clearTimeout(this.staleTimeoutId);\n    this.staleTimeoutId = undefined;\n  };\n\n  _proto.clearRefetchInterval = function clearRefetchInterval() {\n    clearInterval(this.refetchIntervalId);\n    this.refetchIntervalId = undefined;\n  };\n\n  _proto.getNewResult = function getNewResult(willFetch) {\n    var _this$previousQueryRe;\n\n    var state = this.currentQuery.state;\n    var isFetching = state.isFetching,\n        status = state.status;\n    var isPreviousData = false;\n    var isPlaceholderData = false;\n    var data;\n    var dataUpdatedAt = state.dataUpdatedAt; // Optimistically set status to loading if we will start fetching\n\n    if (willFetch) {\n      isFetching = true;\n\n      if (!dataUpdatedAt) {\n        status = 'loading';\n      }\n    } // Keep previous data if needed\n\n\n    if (this.options.keepPreviousData && !state.dataUpdateCount && ((_this$previousQueryRe = this.previousQueryResult) == null ? void 0 : _this$previousQueryRe.isSuccess) && status !== 'error') {\n      data = this.previousQueryResult.data;\n      dataUpdatedAt = this.previousQueryResult.dataUpdatedAt;\n      status = this.previousQueryResult.status;\n      isPreviousData = true;\n    } // Select data if needed\n    else if (this.options.select && typeof state.data !== 'undefined') {\n        var _this$currentResultSt; // Use the previous select result if the query data did not change\n\n\n        if (this.currentResult && state.data === ((_this$currentResultSt = this.currentResultState) == null ? void 0 : _this$currentResultSt.data)) {\n          data = this.currentResult.data;\n        } else {\n          data = this.options.select(state.data);\n\n          if (this.options.structuralSharing !== false) {\n            var _this$currentResult;\n\n            data = replaceEqualDeep((_this$currentResult = this.currentResult) == null ? void 0 : _this$currentResult.data, data);\n          }\n        }\n      } // Use query data\n      else {\n          data = state.data;\n        } // Show placeholder data if needed\n\n\n    if (typeof this.options.placeholderData !== 'undefined' && typeof data === 'undefined' && status === 'loading') {\n      var placeholderData = typeof this.options.placeholderData === 'function' ? this.options.placeholderData() : this.options.placeholderData;\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success';\n        data = placeholderData;\n        isPlaceholderData = true;\n      }\n    }\n\n    var result = _extends({}, getStatusProps(status), {\n      data: data,\n      dataUpdatedAt: dataUpdatedAt,\n      error: state.error,\n      errorUpdatedAt: state.errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount: state.dataUpdateCount > this.initialDataUpdateCount || state.errorUpdateCount > this.initialErrorUpdateCount,\n      isFetching: isFetching,\n      isLoadingError: status === 'error' && state.dataUpdatedAt === 0,\n      isPlaceholderData: isPlaceholderData,\n      isPreviousData: isPreviousData,\n      isRefetchError: status === 'error' && state.dataUpdatedAt !== 0,\n      isStale: this.isStale(),\n      refetch: this.refetch,\n      remove: this.remove\n    });\n\n    return result;\n  };\n\n  _proto.shouldNotifyListeners = function shouldNotifyListeners(prevResult, result) {\n    var _this6 = this;\n\n    var _this$options = this.options,\n        notifyOnChangeProps = _this$options.notifyOnChangeProps,\n        notifyOnChangePropsExclusions = _this$options.notifyOnChangePropsExclusions;\n\n    if (prevResult === result) {\n      return false;\n    }\n\n    if (!notifyOnChangeProps && !notifyOnChangePropsExclusions) {\n      return true;\n    }\n\n    var keys = Object.keys(result);\n    var includedProps = notifyOnChangeProps === 'tracked' ? this.trackedProps : notifyOnChangeProps;\n\n    var _loop = function _loop(i) {\n      var key = keys[i];\n      var changed = prevResult[key] !== result[key];\n      var isIncluded = includedProps == null ? void 0 : includedProps.some(function (x) {\n        return x === key;\n      });\n      var isExcluded = notifyOnChangePropsExclusions == null ? void 0 : notifyOnChangePropsExclusions.some(function (x) {\n        return x === key;\n      });\n\n      if (changed) {\n        if (notifyOnChangePropsExclusions && isExcluded) {\n          return \"continue\";\n        }\n\n        if (!notifyOnChangeProps || isIncluded || notifyOnChangeProps === 'tracked' && _this6.trackedProps.length === 0) {\n          return {\n            v: true\n          };\n        }\n      }\n    };\n\n    for (var i = 0; i < keys.length; i++) {\n      var _ret = _loop(i);\n\n      if (_ret === \"continue\") continue;\n      if (typeof _ret === \"object\") return _ret.v;\n    }\n\n    return false;\n  };\n\n  _proto.updateResult = function updateResult(willFetch) {\n    var _this7 = this;\n\n    var result = this.getNewResult(willFetch); // Keep reference to the current state on which the current result is based on\n\n    this.currentResultState = this.currentQuery.state; // Only update if something has changed\n\n    if (!shallowEqualObjects(result, this.currentResult)) {\n      this.currentResult = result;\n\n      if (this.options.notifyOnChangeProps === 'tracked') {\n        var addTrackedProps = function addTrackedProps(prop) {\n          if (!_this7.trackedProps.includes(prop)) {\n            _this7.trackedProps.push(prop);\n          }\n        };\n\n        this.trackedCurrentResult = {};\n        Object.keys(result).forEach(function (key) {\n          Object.defineProperty(_this7.trackedCurrentResult, key, {\n            configurable: false,\n            enumerable: true,\n            get: function get() {\n              addTrackedProps(key);\n              return result[key];\n            }\n          });\n        });\n      }\n    }\n  };\n\n  _proto.updateQuery = function updateQuery() {\n    var prevQuery = this.currentQuery;\n    var query = this.client.getQueryCache().build(this.client, this.options);\n\n    if (query === prevQuery) {\n      return;\n    }\n\n    this.previousQueryResult = this.currentResult;\n    this.currentQuery = query;\n    this.initialDataUpdateCount = query.state.dataUpdateCount;\n    this.initialErrorUpdateCount = query.state.errorUpdateCount;\n    var willFetch = prevQuery ? this.willFetchOptionally() : this.willFetchOnMount();\n    this.updateResult(willFetch);\n\n    if (!this.hasListeners()) {\n      return;\n    }\n\n    prevQuery == null ? void 0 : prevQuery.removeObserver(this);\n    this.currentQuery.addObserver(this);\n\n    if (this.shouldNotifyListeners(this.previousQueryResult, this.currentResult)) {\n      this.notify({\n        listeners: true\n      });\n    }\n  };\n\n  _proto.onQueryUpdate = function onQueryUpdate(action) {\n    // Store current result and get new result\n    var prevResult = this.currentResult;\n    this.updateResult();\n    var currentResult = this.currentResult; // Update timers\n\n    this.updateTimers(); // Do not notify if the nothing has changed\n\n    if (prevResult === currentResult) {\n      return;\n    } // Determine which callbacks to trigger\n\n\n    var notifyOptions = {};\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true;\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true;\n    }\n\n    if (this.shouldNotifyListeners(prevResult, currentResult)) {\n      notifyOptions.listeners = true;\n    }\n\n    this.notify(notifyOptions);\n  };\n\n  _proto.notify = function notify(notifyOptions) {\n    var _this8 = this;\n\n    notifyManager.batch(function () {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        _this8.options.onSuccess == null ? void 0 : _this8.options.onSuccess(_this8.currentResult.data);\n        _this8.options.onSettled == null ? void 0 : _this8.options.onSettled(_this8.currentResult.data, null);\n      } else if (notifyOptions.onError) {\n        _this8.options.onError == null ? void 0 : _this8.options.onError(_this8.currentResult.error);\n        _this8.options.onSettled == null ? void 0 : _this8.options.onSettled(undefined, _this8.currentResult.error);\n      } // Then trigger the listeners\n\n\n      if (notifyOptions.listeners) {\n        _this8.listeners.forEach(function (listener) {\n          listener(_this8.currentResult);\n        });\n      } // Then the cache listeners\n\n\n      if (notifyOptions.cache) {\n        _this8.client.getQueryCache().notify(_this8.currentQuery);\n      }\n    });\n  };\n\n  return QueryObserver;\n}(Subscribable);","map":{"version":3,"sources":["/home/thomas/Project/React/react-website-v1/node_modules/react-query/es/core/queryObserver.js"],"names":["_extends","_inheritsLoose","getStatusProps","isServer","isValidTimeout","noop","replaceEqualDeep","shallowEqualObjects","timeUntilStale","notifyManager","focusManager","Subscribable","QueryObserver","_Subscribable","client","options","_this","call","initialDataUpdateCount","initialErrorUpdateCount","trackedProps","bindMethods","setOptions","_proto","prototype","remove","bind","refetch","onSubscribe","listeners","length","updateQuery","currentQuery","addObserver","willFetchOnMount","executeFetch","updateTimers","onUnsubscribe","destroy","willLoadOnMount","enabled","state","dataUpdatedAt","status","retryOnMount","willRefetchOnMount","refetchOnMount","isStale","willFetchOnReconnect","refetchOnReconnect","willFetchOnWindowFocus","refetchOnWindowFocus","willFetchOptionally","isStaleByTime","staleTime","clearTimers","removeObserver","prevOptions","prevQuery","defaultQueryObserverOptions","Error","queryKey","optionalFetch","updateStaleTimeout","refetchInterval","updateRefetchInterval","getCurrentResult","currentResult","getTrackedCurrentResult","trackedCurrentResult","getNextResult","_this2","Promise","resolve","reject","unsubscribe","subscribe","result","isFetching","isError","throwOnError","error","getCurrentQuery","getQueryCache","fetch","fetchOptions","_this3","then","updateResult","promise","catch","_this4","clearStaleTimeout","time","timeout","staleTimeoutId","setTimeout","prevResult","notify","shouldNotifyListeners","cache","_this5","clearRefetchInterval","refetchIntervalId","setInterval","refetchIntervalInBackground","isFocused","clearTimeout","undefined","clearInterval","getNewResult","willFetch","_this$previousQueryRe","isPreviousData","isPlaceholderData","data","keepPreviousData","dataUpdateCount","previousQueryResult","isSuccess","select","_this$currentResultSt","currentResultState","structuralSharing","_this$currentResult","placeholderData","errorUpdatedAt","failureCount","fetchFailureCount","isFetched","errorUpdateCount","isFetchedAfterMount","isLoadingError","isRefetchError","_this6","_this$options","notifyOnChangeProps","notifyOnChangePropsExclusions","keys","Object","includedProps","_loop","i","key","changed","isIncluded","some","x","isExcluded","v","_ret","_this7","addTrackedProps","prop","includes","push","forEach","defineProperty","configurable","enumerable","get","query","build","hasListeners","onQueryUpdate","action","notifyOptions","type","onSuccess","onError","_this8","batch","onSettled","listener"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _inheritsLoose from \"@babel/runtime/helpers/esm/inheritsLoose\";\nimport { getStatusProps, isServer, isValidTimeout, noop, replaceEqualDeep, shallowEqualObjects, timeUntilStale } from './utils';\nimport { notifyManager } from './notifyManager';\nimport { focusManager } from './focusManager';\nimport { Subscribable } from './subscribable';\nexport var QueryObserver = /*#__PURE__*/function (_Subscribable) {\n  _inheritsLoose(QueryObserver, _Subscribable);\n\n  function QueryObserver(client, options) {\n    var _this;\n\n    _this = _Subscribable.call(this) || this;\n    _this.client = client;\n    _this.options = options;\n    _this.initialDataUpdateCount = 0;\n    _this.initialErrorUpdateCount = 0;\n    _this.trackedProps = [];\n\n    _this.bindMethods();\n\n    _this.setOptions(options);\n\n    return _this;\n  }\n\n  var _proto = QueryObserver.prototype;\n\n  _proto.bindMethods = function bindMethods() {\n    this.remove = this.remove.bind(this);\n    this.refetch = this.refetch.bind(this);\n  };\n\n  _proto.onSubscribe = function onSubscribe() {\n    if (this.listeners.length === 1) {\n      this.updateQuery();\n      this.currentQuery.addObserver(this);\n\n      if (this.willFetchOnMount()) {\n        this.executeFetch();\n      }\n\n      this.updateTimers();\n    }\n  };\n\n  _proto.onUnsubscribe = function onUnsubscribe() {\n    if (!this.listeners.length) {\n      this.destroy();\n    }\n  };\n\n  _proto.willLoadOnMount = function willLoadOnMount() {\n    return this.options.enabled !== false && !this.currentQuery.state.dataUpdatedAt && !(this.currentQuery.state.status === 'error' && this.options.retryOnMount === false);\n  };\n\n  _proto.willRefetchOnMount = function willRefetchOnMount() {\n    return this.options.enabled !== false && this.currentQuery.state.dataUpdatedAt > 0 && (this.options.refetchOnMount === 'always' || this.options.refetchOnMount !== false && this.isStale());\n  };\n\n  _proto.willFetchOnMount = function willFetchOnMount() {\n    return this.willLoadOnMount() || this.willRefetchOnMount();\n  };\n\n  _proto.willFetchOnReconnect = function willFetchOnReconnect() {\n    return this.options.enabled !== false && (this.options.refetchOnReconnect === 'always' || this.options.refetchOnReconnect !== false && this.isStale());\n  };\n\n  _proto.willFetchOnWindowFocus = function willFetchOnWindowFocus() {\n    return this.options.enabled !== false && (this.options.refetchOnWindowFocus === 'always' || this.options.refetchOnWindowFocus !== false && this.isStale());\n  };\n\n  _proto.willFetchOptionally = function willFetchOptionally() {\n    return this.options.enabled !== false && this.isStale();\n  };\n\n  _proto.isStale = function isStale() {\n    return this.currentQuery.isStaleByTime(this.options.staleTime);\n  };\n\n  _proto.destroy = function destroy() {\n    this.listeners = [];\n    this.clearTimers();\n    this.currentQuery.removeObserver(this);\n  };\n\n  _proto.setOptions = function setOptions(options) {\n    var prevOptions = this.options;\n    var prevQuery = this.currentQuery;\n    this.options = this.client.defaultQueryObserverOptions(options);\n\n    if (typeof this.options.enabled !== 'undefined' && typeof this.options.enabled !== 'boolean') {\n      throw new Error('Expected enabled to be a boolean');\n    } // Keep previous query key if the user does not supply one\n\n\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey;\n    }\n\n    this.updateQuery(); // Take no further actions if there are no subscribers\n\n    if (!this.listeners.length) {\n      return;\n    } // If we subscribed to a new query, optionally fetch and update refetch\n\n\n    if (this.currentQuery !== prevQuery) {\n      this.optionalFetch();\n      this.updateTimers();\n      return;\n    } // Optionally fetch if the query became enabled\n\n\n    if (this.options.enabled !== false && prevOptions.enabled === false) {\n      this.optionalFetch();\n    } // Update stale interval if needed\n\n\n    if (this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime) {\n      this.updateStaleTimeout();\n    } // Update refetch interval if needed\n\n\n    if (this.options.enabled !== prevOptions.enabled || this.options.refetchInterval !== prevOptions.refetchInterval) {\n      this.updateRefetchInterval();\n    }\n  };\n\n  _proto.getCurrentResult = function getCurrentResult() {\n    return this.currentResult;\n  };\n\n  _proto.getTrackedCurrentResult = function getTrackedCurrentResult() {\n    return this.trackedCurrentResult;\n  };\n\n  _proto.getNextResult = function getNextResult(options) {\n    var _this2 = this;\n\n    return new Promise(function (resolve, reject) {\n      var unsubscribe = _this2.subscribe(function (result) {\n        if (!result.isFetching) {\n          unsubscribe();\n\n          if (result.isError && (options == null ? void 0 : options.throwOnError)) {\n            reject(result.error);\n          } else {\n            resolve(result);\n          }\n        }\n      });\n    });\n  };\n\n  _proto.getCurrentQuery = function getCurrentQuery() {\n    return this.currentQuery;\n  };\n\n  _proto.remove = function remove() {\n    this.client.getQueryCache().remove(this.currentQuery);\n  };\n\n  _proto.refetch = function refetch(options) {\n    return this.fetch(options);\n  };\n\n  _proto.fetch = function fetch(fetchOptions) {\n    var _this3 = this;\n\n    return this.executeFetch(fetchOptions).then(function () {\n      _this3.updateResult();\n\n      return _this3.currentResult;\n    });\n  };\n\n  _proto.optionalFetch = function optionalFetch() {\n    if (this.willFetchOptionally()) {\n      this.executeFetch();\n    }\n  };\n\n  _proto.executeFetch = function executeFetch(fetchOptions) {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.updateQuery(); // Fetch\n\n    var promise = this.currentQuery.fetch(this.options, fetchOptions);\n\n    if (!(fetchOptions == null ? void 0 : fetchOptions.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  };\n\n  _proto.updateStaleTimeout = function updateStaleTimeout() {\n    var _this4 = this;\n\n    this.clearStaleTimeout();\n\n    if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {\n      return;\n    }\n\n    var time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime); // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n\n    var timeout = time + 1;\n    this.staleTimeoutId = setTimeout(function () {\n      if (!_this4.currentResult.isStale) {\n        var prevResult = _this4.currentResult;\n\n        _this4.updateResult();\n\n        _this4.notify({\n          listeners: _this4.shouldNotifyListeners(prevResult, _this4.currentResult),\n          cache: true\n        });\n      }\n    }, timeout);\n  };\n\n  _proto.updateRefetchInterval = function updateRefetchInterval() {\n    var _this5 = this;\n\n    this.clearRefetchInterval();\n\n    if (isServer || this.options.enabled === false || !isValidTimeout(this.options.refetchInterval)) {\n      return;\n    }\n\n    this.refetchIntervalId = setInterval(function () {\n      if (_this5.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        _this5.executeFetch();\n      }\n    }, this.options.refetchInterval);\n  };\n\n  _proto.updateTimers = function updateTimers() {\n    this.updateStaleTimeout();\n    this.updateRefetchInterval();\n  };\n\n  _proto.clearTimers = function clearTimers() {\n    this.clearStaleTimeout();\n    this.clearRefetchInterval();\n  };\n\n  _proto.clearStaleTimeout = function clearStaleTimeout() {\n    clearTimeout(this.staleTimeoutId);\n    this.staleTimeoutId = undefined;\n  };\n\n  _proto.clearRefetchInterval = function clearRefetchInterval() {\n    clearInterval(this.refetchIntervalId);\n    this.refetchIntervalId = undefined;\n  };\n\n  _proto.getNewResult = function getNewResult(willFetch) {\n    var _this$previousQueryRe;\n\n    var state = this.currentQuery.state;\n    var isFetching = state.isFetching,\n        status = state.status;\n    var isPreviousData = false;\n    var isPlaceholderData = false;\n    var data;\n    var dataUpdatedAt = state.dataUpdatedAt; // Optimistically set status to loading if we will start fetching\n\n    if (willFetch) {\n      isFetching = true;\n\n      if (!dataUpdatedAt) {\n        status = 'loading';\n      }\n    } // Keep previous data if needed\n\n\n    if (this.options.keepPreviousData && !state.dataUpdateCount && ((_this$previousQueryRe = this.previousQueryResult) == null ? void 0 : _this$previousQueryRe.isSuccess) && status !== 'error') {\n      data = this.previousQueryResult.data;\n      dataUpdatedAt = this.previousQueryResult.dataUpdatedAt;\n      status = this.previousQueryResult.status;\n      isPreviousData = true;\n    } // Select data if needed\n    else if (this.options.select && typeof state.data !== 'undefined') {\n        var _this$currentResultSt;\n\n        // Use the previous select result if the query data did not change\n        if (this.currentResult && state.data === ((_this$currentResultSt = this.currentResultState) == null ? void 0 : _this$currentResultSt.data)) {\n          data = this.currentResult.data;\n        } else {\n          data = this.options.select(state.data);\n\n          if (this.options.structuralSharing !== false) {\n            var _this$currentResult;\n\n            data = replaceEqualDeep((_this$currentResult = this.currentResult) == null ? void 0 : _this$currentResult.data, data);\n          }\n        }\n      } // Use query data\n      else {\n          data = state.data;\n        } // Show placeholder data if needed\n\n\n    if (typeof this.options.placeholderData !== 'undefined' && typeof data === 'undefined' && status === 'loading') {\n      var placeholderData = typeof this.options.placeholderData === 'function' ? this.options.placeholderData() : this.options.placeholderData;\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success';\n        data = placeholderData;\n        isPlaceholderData = true;\n      }\n    }\n\n    var result = _extends({}, getStatusProps(status), {\n      data: data,\n      dataUpdatedAt: dataUpdatedAt,\n      error: state.error,\n      errorUpdatedAt: state.errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount: state.dataUpdateCount > this.initialDataUpdateCount || state.errorUpdateCount > this.initialErrorUpdateCount,\n      isFetching: isFetching,\n      isLoadingError: status === 'error' && state.dataUpdatedAt === 0,\n      isPlaceholderData: isPlaceholderData,\n      isPreviousData: isPreviousData,\n      isRefetchError: status === 'error' && state.dataUpdatedAt !== 0,\n      isStale: this.isStale(),\n      refetch: this.refetch,\n      remove: this.remove\n    });\n\n    return result;\n  };\n\n  _proto.shouldNotifyListeners = function shouldNotifyListeners(prevResult, result) {\n    var _this6 = this;\n\n    var _this$options = this.options,\n        notifyOnChangeProps = _this$options.notifyOnChangeProps,\n        notifyOnChangePropsExclusions = _this$options.notifyOnChangePropsExclusions;\n\n    if (prevResult === result) {\n      return false;\n    }\n\n    if (!notifyOnChangeProps && !notifyOnChangePropsExclusions) {\n      return true;\n    }\n\n    var keys = Object.keys(result);\n    var includedProps = notifyOnChangeProps === 'tracked' ? this.trackedProps : notifyOnChangeProps;\n\n    var _loop = function _loop(i) {\n      var key = keys[i];\n      var changed = prevResult[key] !== result[key];\n      var isIncluded = includedProps == null ? void 0 : includedProps.some(function (x) {\n        return x === key;\n      });\n      var isExcluded = notifyOnChangePropsExclusions == null ? void 0 : notifyOnChangePropsExclusions.some(function (x) {\n        return x === key;\n      });\n\n      if (changed) {\n        if (notifyOnChangePropsExclusions && isExcluded) {\n          return \"continue\";\n        }\n\n        if (!notifyOnChangeProps || isIncluded || notifyOnChangeProps === 'tracked' && _this6.trackedProps.length === 0) {\n          return {\n            v: true\n          };\n        }\n      }\n    };\n\n    for (var i = 0; i < keys.length; i++) {\n      var _ret = _loop(i);\n\n      if (_ret === \"continue\") continue;\n      if (typeof _ret === \"object\") return _ret.v;\n    }\n\n    return false;\n  };\n\n  _proto.updateResult = function updateResult(willFetch) {\n    var _this7 = this;\n\n    var result = this.getNewResult(willFetch); // Keep reference to the current state on which the current result is based on\n\n    this.currentResultState = this.currentQuery.state; // Only update if something has changed\n\n    if (!shallowEqualObjects(result, this.currentResult)) {\n      this.currentResult = result;\n\n      if (this.options.notifyOnChangeProps === 'tracked') {\n        var addTrackedProps = function addTrackedProps(prop) {\n          if (!_this7.trackedProps.includes(prop)) {\n            _this7.trackedProps.push(prop);\n          }\n        };\n\n        this.trackedCurrentResult = {};\n        Object.keys(result).forEach(function (key) {\n          Object.defineProperty(_this7.trackedCurrentResult, key, {\n            configurable: false,\n            enumerable: true,\n            get: function get() {\n              addTrackedProps(key);\n              return result[key];\n            }\n          });\n        });\n      }\n    }\n  };\n\n  _proto.updateQuery = function updateQuery() {\n    var prevQuery = this.currentQuery;\n    var query = this.client.getQueryCache().build(this.client, this.options);\n\n    if (query === prevQuery) {\n      return;\n    }\n\n    this.previousQueryResult = this.currentResult;\n    this.currentQuery = query;\n    this.initialDataUpdateCount = query.state.dataUpdateCount;\n    this.initialErrorUpdateCount = query.state.errorUpdateCount;\n    var willFetch = prevQuery ? this.willFetchOptionally() : this.willFetchOnMount();\n    this.updateResult(willFetch);\n\n    if (!this.hasListeners()) {\n      return;\n    }\n\n    prevQuery == null ? void 0 : prevQuery.removeObserver(this);\n    this.currentQuery.addObserver(this);\n\n    if (this.shouldNotifyListeners(this.previousQueryResult, this.currentResult)) {\n      this.notify({\n        listeners: true\n      });\n    }\n  };\n\n  _proto.onQueryUpdate = function onQueryUpdate(action) {\n    // Store current result and get new result\n    var prevResult = this.currentResult;\n    this.updateResult();\n    var currentResult = this.currentResult; // Update timers\n\n    this.updateTimers(); // Do not notify if the nothing has changed\n\n    if (prevResult === currentResult) {\n      return;\n    } // Determine which callbacks to trigger\n\n\n    var notifyOptions = {};\n\n    if (action.type === 'success') {\n      notifyOptions.onSuccess = true;\n    } else if (action.type === 'error') {\n      notifyOptions.onError = true;\n    }\n\n    if (this.shouldNotifyListeners(prevResult, currentResult)) {\n      notifyOptions.listeners = true;\n    }\n\n    this.notify(notifyOptions);\n  };\n\n  _proto.notify = function notify(notifyOptions) {\n    var _this8 = this;\n\n    notifyManager.batch(function () {\n      // First trigger the configuration callbacks\n      if (notifyOptions.onSuccess) {\n        _this8.options.onSuccess == null ? void 0 : _this8.options.onSuccess(_this8.currentResult.data);\n        _this8.options.onSettled == null ? void 0 : _this8.options.onSettled(_this8.currentResult.data, null);\n      } else if (notifyOptions.onError) {\n        _this8.options.onError == null ? void 0 : _this8.options.onError(_this8.currentResult.error);\n        _this8.options.onSettled == null ? void 0 : _this8.options.onSettled(undefined, _this8.currentResult.error);\n      } // Then trigger the listeners\n\n\n      if (notifyOptions.listeners) {\n        _this8.listeners.forEach(function (listener) {\n          listener(_this8.currentResult);\n        });\n      } // Then the cache listeners\n\n\n      if (notifyOptions.cache) {\n        _this8.client.getQueryCache().notify(_this8.currentQuery);\n      }\n    });\n  };\n\n  return QueryObserver;\n}(Subscribable);"]},"metadata":{},"sourceType":"module"}